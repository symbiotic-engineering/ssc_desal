component constant_volume_chamber
% Constant Volume Chamber (SS)
% This block models mass and energy storage in a thermal liquid network.
% The chamber contains a constant volume of liquid. Pressure and
% temperature evolve based on the dynamic compressibility and thermal
% capacity of this liquid volume.
%
% Ports A, B, C, and D are the thermal liquid conserving ports associated
% with the chamber inlets. Port H is the thermal conserving port associated
% with the thermal mass of the liquid volume.

nodes
    A = customization.solution.solution; % A
    H = foundation.thermal.thermal;               % H
end

nodes (ExternalAccess = none)
    B = customization.solution.solution; % B
    C = customization.solution.solution; % C
    D = customization.solution.solution; % D
end

inputs
    dM_X = {0,"kg/s"}; % dM_X
end

outputs (ExternalAccess = none)
    M = {0,"kg"}; % M
    P = {0.101325,"MPa"}; % P
    T = {293.15,"K"}; % T
    X = {0,"kg/m^3"}; % X
end

annotations
    [A,H,dM_X] : Side = left;
    [B,C,D] : Side = right;
    [M,P,T,X] : Side = bottom;
end

parameters
    volume = {0.001, 'm^3'}; % Chamber volume
    num_ports = foundation.enum.num_ports.one; % Number of ports
    %                                            1 - one
    %                                            2 - two
    %                                            3 - three
    %                                            4 - four
    area_A = {0.01,  'm^2'}; % Cross-sectional area at port A
end
parameters (ExternalAccess = none)
    area_B = {0.01,  'm^2'}; % Cross-sectional area at port B
    area_C = {0.01,  'm^2'}; % Cross-sectional area at port C
    area_D = {0.01,  'm^2'}; % Cross-sectional area at port D
end

% Icons
if num_ports == foundation.enum.num_ports.one
    annotations
        Icon = 'constant_volume_chamber.svg';
    end
elseif num_ports == foundation.enum.num_ports.two
    annotations
        Icon = 'constant_volume_chamber_2ports.svg';
    end
elseif num_ports == foundation.enum.num_ports.three
    annotations
        Icon = 'constant_volume_chamber_3ports.svg';
    end
else % num_ports == foundation.enum.num_ports.four
    annotations
        Icon = 'constant_volume_chamber_4ports.svg';
    end
end


% Parameter checks and visibility
equations
    assert(volume > 0)
    assert(area_A > 0)
end
if num_ports >= 2
    annotations
        [B, area_B] : ExternalAccess = modify;
        [mdot_B, Phi_B, mdot_B_x] : ExternalAccess = observe;
    end
    equations
        assert(area_B > 0)
    end
end
if num_ports >= 3
    annotations
        [C, area_C] : ExternalAccess = modify;
        [mdot_C, Phi_C, mdot_C_x] : ExternalAccess = observe;
    end
    equations
        assert(area_C > 0)
    end
end
if num_ports >= 4
    annotations
        [D, area_D] : ExternalAccess = modify;
        [mdot_D, Phi_D, mdot_D_x] : ExternalAccess = observe;
    end
    equations
        assert(area_D > 0)
    end
end

parameters
    m_measure = false; % Mass
    p_measure = false; % Pressure
    t_measure = false; % Temperature
    x_measure = false; % Species concentration
end

annotations
    UILayout = [UIGroup("Parameters",volume,num_ports,area_A,area_B,area_C,area_D)
        UIGroup("Measurements",m_measure,p_measure,t_measure,x_measure)];
end

if m_measure
    annotations
        M : ExternalAccess = modify
    end
end
if p_measure
    annotations
        P : ExternalAccess = modify
    end
end
if t_measure
    annotations
        T : ExternalAccess = modify
    end
end
if x_measure
    annotations
        X : ExternalAccess = modify
    end
end

variables
    p_I   = {value = {0.101325, 'MPa'}, priority = priority.high}; % Pressure of liquid volume
    T_I   = {value = {293.15,   'K'  }, priority = priority.high}; % Temperature of liquid volume
    u_I   = {83.906, 'kJ/kg' };                                    % Specific internal energy of liquid volume
    rho_I = {998.21, 'kg/m^3'};                                    % Density of liquid volume
    x_I   = {0,'kg/m^3'};                                          % Species concentration of liquid volume
end
variables (Access = protected)
    mdot_A = {0, 'kg/s'}; % Mass flow rate into port A
    Phi_A  = {0, 'kW'  }; % Energy flow rate into port A
    mdot_A_x = {0, 'kg/s'}; % Species flow rate into port A
    Q_H    = {0, 'kW'  }; % Heat flow rate into port H
end
variables (Access = protected, ExternalAccess = none)
    mdot_B = {0, 'kg/s'}; % Mass flow rate into port B
    mdot_C = {0, 'kg/s'}; % Mass flow rate into port C
    mdot_D = {0, 'kg/s'}; % Mass flow rate into port D
    Phi_B  = {0, 'kW'  }; % Energy flow rate into port B
    Phi_C  = {0, 'kW'  }; % Energy flow rate into port C
    Phi_D  = {0, 'kW'  }; % Energy flow rate into port D
    mdot_B_x = {0, 'kg/s'}; % Species flow rate into port B
    mdot_C_x = {0, 'kg/s'}; % Species flow rate into port C
    mdot_D_x = {0, 'kg/s'}; % Species flow rate into port D
end

branches
    mdot_A : A.mdot -> *;
    mdot_B : B.mdot -> *;
    mdot_C : C.mdot -> *;
    mdot_D : D.mdot -> *;
    Phi_A  : A.Phi  -> *;
    Phi_B  : B.Phi  -> *;
    Phi_C  : C.Phi  -> *;
    Phi_D  : D.Phi  -> *;
    mdot_A_x : A.mdot_x -> *;
    mdot_B_x : B.mdot_x -> *;
    mdot_C_x : C.mdot_x -> *;
    mdot_D_x : D.mdot_x -> *;
    Q_H    : H.Q    -> *;
end

intermediates (Access = private, ExternalAccess = none)
    % Liquid properties table lookup
    cp_I    = tablelookup(A.T_TLU, A.p_TLU, A.cp_TLU,    T_I, p_I, interpolation = linear, extrapolation = linear);
    beta_I  = tablelookup(A.T_TLU, A.p_TLU, A.beta_TLU,  T_I, p_I, interpolation = linear, extrapolation = linear);
    alpha_I = tablelookup(A.T_TLU, A.p_TLU, A.alpha_TLU, T_I, p_I, interpolation = linear, extrapolation = linear);

    % Partial derivatives of internal energy of liquid volume
    % with respect to pressure and temperature
    dUdp = (rho_I * h_I / beta_I - T_I * alpha_I) * volume;
    dUdT = (cp_I - h_I * alpha_I) * rho_I * volume;
end

% For logging
intermediates (Access = private)
    h_I = u_I + p_I/rho_I; % Specific enthalpy of liquid volume
end

annotations
    h_I : LoggingUnit = 'kJ/kg';
end

equations
    % Assume no flow resistance
    A.p == p_I;
    B.p == p_I;
    C.p == p_I;
    D.p == p_I;

    % Assume no thermal resistance
    H.T == T_I;

    % Mass conservation
    (der(p_I)/beta_I - der(T_I)*alpha_I) * rho_I * volume == mdot_A + mdot_B + mdot_C + mdot_D;

    % Energy conservation
    der(p_I)*dUdp + der(T_I)*dUdT == Phi_A + Phi_B + Phi_C + Phi_D + Q_H;

    % Liquid properties table lookup
    rho_I == x_I + tablelookup(A.T_TLU, A.p_TLU, A.rho_TLU, T_I, p_I, interpolation = linear, extrapolation = linear);
    u_I   == tablelookup(A.T_TLU, A.p_TLU, A.u_TLU,   T_I, p_I, interpolation = linear, extrapolation = linear);

    % Conservation of tracked species
    der(x_I) * volume == mdot_A_x + mdot_B_x + mdot_C_x + mdot_D_x + dM_X;

    % Signal outputs
    M == volume * rho_I;
    P == p_I;
    T == T_I;
    X == x_I;

    % Run-time variable checks
    let
        % Indicator variables for the valid region of the property tables
        indicator_pT_I = ...
            if A.pT_region_flag == foundation.enum.pT_region_TL.validity_matrix, ...
                tablelookup(A.T_TLU, A.p_TLU, A.pT_validity_TLU, T_I, p_I, interpolation = linear, extrapolation = linear) ...
            else ...
                1 ...
            end;
    in
        % Pressure and temperature must be within the valid region
        assert(indicator_pT_I > 0, message('physmod:simscape:library:thermal_liquid:PressureTemperatureVolumeValidRegion'), Action = A.properties_range_check)
        assert(p_I >= A.p_min, Action = A.properties_range_check)
        assert(p_I <= A.p_max, Action = A.properties_range_check)
        assert(T_I >= A.T_min, Action = A.properties_range_check)
        assert(T_I <= A.T_max, Action = A.properties_range_check)
    end
end

% Internal component that calculates energy convection at port A
components (ExternalAccess = none)
    convection_A = customization.solution.port_convection(flow_area = area_A, length_scale = sqrt(4*area_A/pi));
end
connections
    connect(A, convection_A.port)
end
% Equate variables for internal component that calculates energy convection at port A
equations
    convection_A.mdot == mdot_A;
    convection_A.Phi  == Phi_A;
    convection_A.mdot_x == mdot_A_x;
    convection_A.u_I  == u_I;
    convection_A.x_I  == x_I;
end

if num_ports >= 2
    % Internal component that calculates energy convection at port B
    components (ExternalAccess = none)
        convection_B = customization.solution.port_convection(flow_area = area_B, length_scale = sqrt(4*area_B/pi));
    end
    connections
        connect(B, convection_B.port)
    end
    % Equate variables for internal component that calculates energy convection at port B
    equations
        convection_B.mdot == mdot_B;
        convection_B.Phi  == Phi_B;
        convection_B.mdot_x == mdot_B_x;
        convection_B.u_I  == u_I;
        convection_B.x_I  == x_I;
    end
else
    equations
        B.T == T_I;
        B.x == x_I;
    end
end

if num_ports >= 3
    % Internal component that calculates energy convection at port C
    components (ExternalAccess = none)
        convection_C = customization.solution.port_convection(flow_area = area_C, length_scale = sqrt(4*area_C/pi));
    end
    connections
        connect(C, convection_C.port)
    end
    % Equate variables for internal component that calculates energy convection at port C
    equations
        convection_C.mdot == mdot_C;
        convection_C.Phi  == Phi_C;
        convection_C.mdot_x == mdot_C_x;
        convection_C.u_I  == u_I;
        convection_C.x_I  == x_I;
    end
else
    equations
        C.T == T_I;
        C.x == x_I;
    end
end

if num_ports >= 4
    % Internal component that calculates energy convection at port D
    components (ExternalAccess = none)
        convection_D = customization.solution.port_convection(flow_area = area_D, length_scale = sqrt(4*area_D/pi));
    end
    connections
        connect(D, convection_D.port)
    end
    % Equate variables for internal component that calculates energy convection at port D
    equations
        convection_D.mdot == mdot_D;
        convection_D.Phi  == Phi_D;
        convection_D.mdot_x == mdot_D_x;
        convection_D.u_I  == u_I;
        convection_D.x_I  == x_I;
    end
else
    equations
        D.T == T_I;
        D.x == x_I;
    end
end

end