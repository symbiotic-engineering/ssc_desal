component translational_mechanical_converter
% Translational Mechanical Converter (TL Custom) : 2
% This block models an interface between a thermal liquid network and a
% mechanical translational network. It can be used as a building block for
% linear actuators.
%
% The converter contains a variable volume of liquid. Temperature evolves
% based on the thermal capacity of this liquid volume. Setting Fluid
% dynamic compressibility to On also causes pressure to evolve based on the
% dynamic compressibility of the liquid volume.
%
% Port A is the thermal liquid conserving port associated with the
% converter inlet. Port H is the thermal conserving port associated with
% the thermal mass of the liquid volume. Ports R and C are the mechanical
% translational conserving ports associated with the moving interface and
% the converter casing, respectively. The displacement of port R relative
% to port C can be calculated internally or be set by the physical signal
% input port p. The displacement is defined to be zero when the liquid
% volume is equal to the dead volume.

% Copyright 2012-2023 The MathWorks, Inc.

inputs (ExternalAccess = none)
    % Displacement of port R relative to port C
    p_in = {0, 'm'}; % p
end

nodes
    A = customization.thermal_liquid_custom.thermal_liquid_custom; % A          % A
    C = foundation.mechanical.translational.translational; % C
    R = foundation.mechanical.translational.translational; % R
    H = foundation.thermal.thermal;                        % H
end

annotations
    [A, C, H] : Side = left;
    [p_in, R] : Side = right;
end

parameters
    mech_orientation = foundation.enum.MechOrientationTranslational.Positive; % Mechanical orientation
    %                                                                            1 - Positive
    %                                                                           -1 - Negative
    displacement_spec = foundation.enum.DisplacementSpec.Calculate; % Interface displacement
    %                                                                 1 - Calculate
    %                                                                 2 - InputSignal
end
parameters (ExternalAccess = none)
    x0               = {0,    'm'  }; % Initial interface displacement
end
parameters
    interface_area   = {0.01, 'm^2'}; % Interface cross-sectional area
    dead_volume      = {1e-5, 'm^3'}; % Dead volume
    environment_spec = foundation.enum.pressure_spec.atmospheric; % Environment pressure specification
    %                                                               1 - atmospheric
    %                                                               2 - specified
end
parameters (ExternalAccess = none)
    environment_pressure = {0.101325, 'MPa'}; % Environment pressure
end
parameters
    dynamic_compressibility = simscape.enum.onoff.on; % Fluid dynamic compressibility
end
parameters (ExternalAccess = none)
    p0 = {0.101325, 'MPa'}; % Initial liquid pressure
end
parameters
    T0 = {293.15,   'K'  }; % Initial liquid temperature
    x0_fluid = {0,'kg/m^3'}; % Initial species concentration
end

% Parameter groups
annotations
    UILayout = [
        UIGroup('physmod:simscape:library:tabs:Main', ...
            mech_orientation, displacement_spec, x0, interface_area, dead_volume, ...
            environment_spec, environment_pressure)
        UIGroup('physmod:simscape:library:tabs:EffectsAndInitialConditions', ...
            dynamic_compressibility, p0, T0, x0_fluid)]
end

parameters (Access = private)
    min_volume = 1e-4 * dead_volume; % minimum physical volume
end

% Parameter checks and visibility
equations
    assert(interface_area > 0)
    assert(dead_volume > 0)
    assert(T0 >= A.T_min)
    assert(T0 <= A.T_max)
    assert(x0_fluid >= 0)
end

if displacement_spec == foundation.enum.DisplacementSpec.Calculate
    annotations
        x0 : ExternalAccess = modify;
    end
    parameters (Access = private)
        x0_priority = priority.high;
    end
    if mech_orientation == foundation.enum.MechOrientationTranslational.Positive
        annotations
            Icon = 'translational_mechanical_converter.svg';
        end
        parameters (Access = private)
            mech_sign = 1;
        end
        equations
            assert(x0 >= 0)
        end
    else % mech_orientation == foundation.enum.MechOrientationTranslational.Negative
        annotations
            Icon = 'translational_mechanical_converter_negative.svg';
        end
        parameters (Access = private)
            mech_sign = -1;
        end
        equations
            assert(x0 <= 0)
        end
    end
else % displacement_spec == foundation.enum.DisplacementSpec.InputSignal
    annotations
        p_in : ExternalAccess = modify;
    end
    parameters (Access = private)
        x0_priority = priority.none;
    end
    if mech_orientation == foundation.enum.MechOrientationTranslational.Positive
        annotations
            Icon = 'translational_mechanical_converter_input.svg';
        end
        parameters (Access = private)
            mech_sign = 1;
        end
    else % mech_orientation == foundation.enum.MechOrientationTranslational.Negative
        annotations
            Icon = 'translational_mechanical_converter_negative_input.svg';
        end
        parameters (Access = private)
            mech_sign = -1;
        end
    end
end

if environment_spec == foundation.enum.pressure_spec.atmospheric
    parameters (Access = private)
        p_environment = A.p_atm;
    end
else % environment_spec == foundation.enum.pressure_spec.specified
    annotations
        environment_pressure : ExternalAccess = modify;
    end
    parameters (Access = private)
        p_environment = environment_pressure;
    end
    equations
        assert(environment_pressure >= 0)
    end
end

if dynamic_compressibility == simscape.enum.onoff.on
    annotations
        p0 : ExternalAccess = modify;
    end
    parameters (Access = private)
        p_priority = priority.high;
    end
    equations
        assert(p0 >= A.p_min)
        assert(p0 <= A.p_max)
    end
else % dynamic_compressibility == simscape.enum.onoff.off
    parameters (Access = private)
        p_priority = priority.none;
    end
end

variables (Access = protected)
    mdot_A = {0, 'kg/s'}; % Mass flow rate into port A
    Phi_A  = {0, 'kW'  }; % Energy flow rate into port A
    mdot_A_x = {0, 'kg/s'}; % Species mass flow rate into port A
    Q_H    = {0, 'kW'  }; % Heat flow rate into port H

    p_I = {value = p0, priority = p_priority   }; % Pressure of liquid volume
    T_I = {value = T0, priority = priority.high}; % Temperature of liquid volume
    x_I = {value = x0_fluid, priority = priority.high}; % Species concentration
    interface_force        = {0, 'N'}; % Liquid-exerted force on the interface
    interface_displacement = {value = x0, priority = x0_priority}; % Interface displacement
end

branches
    mdot_A          : A.mdot -> *;
    Phi_A           : A.Phi  -> *;
    mdot_A_x         : A.mdot_x -> *;
    Q_H             : H.Q    -> *;
    interface_force : R.f    -> C.f;
end


% Determine displacement of port R relative to port C
if displacement_spec == foundation.enum.DisplacementSpec.Calculate
    equations
        der(interface_displacement) == interface_velocity;
    end
else % displacement_spec == foundation.enum.DisplacementSpec.InputSignal
    equations
        interface_displacement == p_in;
    end
end

intermediates (Access = private, ExternalAccess = none)
    % Liquid properties table lookup
    cp_I = tablelookup(A.T_TLU, A.p_TLU, A.cp_TLU, T_I, p_I, interpolation = linear, extrapolation = linear);

    % Change in liquid volume
    der_volume = interface_area * interface_velocity * mech_sign;
end

% For logging
intermediates (Access = private)
    rho_I = tablelookup(A.T_TLU, A.p_TLU, A.rho_TLU, T_I, p_I, interpolation = linear, extrapolation = linear); % Density of liquid volume
    u_I   = tablelookup(A.T_TLU, A.p_TLU, A.u_TLU,   T_I, p_I, interpolation = linear, extrapolation = linear); % Specific internal energy of liquid volume
    h_I   = u_I + p_I/rho_I; % Specific enthalpy of liquid volume

    interface_velocity = R.v - C.v; % Interface velocity
    volume = dead_volume + interface_area * interface_displacement * mech_sign; % Liquid volume
end

annotations
    rho_I              : LoggingUnit = 'kg/m^3';
    [u_I, h_I]         : LoggingUnit = 'kJ/kg';
    volume             : LoggingUnit = 'm^3';
    interface_velocity : LoggingUnit = 'm/s';
end

if dynamic_compressibility == simscape.enum.onoff.off

    equations
        % Mass balance
        rho_I * der_volume == mdot_A;

        % Energy conservation
        der(T_I) * cp_I * rho_I * volume + rho_I * h_I * der_volume == Phi_A + Q_H;
    end

else % dynamic_compressibility == simscape.enum.onoff.on

    intermediates (Access = private, ExternalAccess = none)
        % Liquid properties table lookup
        beta_I  = tablelookup(A.T_TLU, A.p_TLU, A.beta_TLU,  T_I, p_I, interpolation = linear, extrapolation = linear);
        alpha_I = tablelookup(A.T_TLU, A.p_TLU, A.alpha_TLU, T_I, p_I, interpolation = linear, extrapolation = linear);

        % Partial derivatives of internal energy of liquid volume
        % with respect to pressure and temperature at constant volume
        dUdp = (rho_I * h_I / beta_I - T_I * alpha_I) * volume;
        dUdT = (cp_I - h_I * alpha_I) * rho_I * volume;
    end

    equations
        % Mass conservation
        (der(p_I)/beta_I - der(T_I)*alpha_I) * rho_I * volume + rho_I * der_volume == mdot_A;

        % Energy conservation
        der(p_I)*dUdp + der(T_I)*dUdT + rho_I * h_I * der_volume == Phi_A + Q_H;
    end

end

equations
    % Assume no flow resistance
    A.p == p_I;

    % Assume no thermal resistance
    H.T == T_I;

    % Force balance on mechanical interface
    interface_force / interface_area == (p_environment - p_I) * mech_sign;

    % Species conservation
    der(x_I) * volume + x_I * der_volume == mdot_A_x;

    % Run-time variable checks
    assert(volume > min_volume)
    let
        % Indicator variables for the valid region of the property tables
        indicator_pT_I = ...
            if A.pT_region_flag == foundation.enum.pT_region_TL.validity_matrix, ...
                tablelookup(A.T_TLU, A.p_TLU, A.pT_validity_TLU, T_I, p_I, interpolation = linear, extrapolation = linear) ...
            else ...
                1 ...
            end;
    in
        % Pressure and temperature must be within the valid region
        assert(indicator_pT_I > 0, message('physmod:simscape:library:thermal_liquid:PressureTemperatureVolumeValidRegion'), Action = A.properties_range_check)
        assert(p_I >= A.p_min, Action = A.properties_range_check)
        assert(p_I <= A.p_max, Action = A.properties_range_check)
        assert(T_I >= A.T_min, Action = A.properties_range_check)
        assert(T_I <= A.T_max, Action = A.properties_range_check)
    end
end

% Internal component that calculates energy convection at port A
components (ExternalAccess = none)
    convection_A = customization.thermal_liquid_custom.port_convection(flow_area = interface_area, length_scale = sqrt(4*interface_area/pi));
end
connections
    connect(A, convection_A.port)
end

% Equate variables for internal component that calculates energy convection at port A
equations
    convection_A.mdot == mdot_A;
    convection_A.Phi  == Phi_A;
    convection_A.mdot_x == mdot_A_x;
    convection_A.u_I  == u_I;
    convection_A.x_I  == x_I;
end

end