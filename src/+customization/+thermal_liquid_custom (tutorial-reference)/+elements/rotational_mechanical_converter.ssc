component rotational_mechanical_converter
% Rotational Mechanical Converter (TL Custom) : 1.5
% This block models an interface between a thermal liquid network and a
% mechanical rotational network. It can be used as a building block for
% rotary actuators.
%
% The converter contains a variable volume of liquid. Temperature evolves
% based on the thermal capacity of this liquid volume. Setting Fluid
% dynamic compressibility to On also causes pressure to evolve based on the
% dynamic compressibility of the liquid volume.
%
% Port A is the thermal liquid conserving port associated with the
% converter inlet. Port H is the thermal conserving port associated with
% the thermal mass of the liquid volume. Ports R and C are the mechanical
% rotational conserving ports associated with the moving interface and the
% converter casing, respectively. The rotation of port R relative to port C
% can be calculated internally or be set by the physical signal input port
% q. The rotation is defined to be zero when the liquid volume is equal to
% the dead volume.

% Copyright 2012-2023 The MathWorks, Inc.

nodes
    A = customization.thermal_liquid_custom.thermal_liquid_custom; % A
    H = foundation.thermal.thermal;               % H
end

inputs (ExternalAccess = none)
    % Rotation of port R relative to port C
    q_in = {0, 'rad'}; % q
end

nodes
    R = foundation.mechanical.rotational.rotational; % R
    C = foundation.mechanical.rotational.rotational; % C
end

annotations
    [A, q_in, R] : Side = left;
    [H, C]       : Side = right;
end

parameters
    mech_orientation = foundation.enum.MechOrientationRotational.Positive; % Mechanical orientation
    %                                                                         1 - Positive
    %                                                                        -1 - Negative
    rotation_spec = foundation.enum.RotationSpec.Calculate; % Interface rotation
    %                                                         1 - Calculate
    %                                                         2 - InputSignal
end
parameters (ExternalAccess = none)
    theta0              = {0,      'rad'    }; % Initial interface rotation
end
parameters
    volume_displacement = {1.2e-4, 'm^3/rad'}; % Interface volume displacement
    dead_volume         = {1e-5,   'm^3'    }; % Dead volume
    area                = {0.01,   'm^2'    }; % Cross-sectional area at port A
    environment_spec = foundation.enum.pressure_spec.atmospheric; % Environment pressure specification
    %                                                               1 - atmospheric
    %                                                               2 - specified
end
parameters (ExternalAccess = none)
    environment_pressure = {0.101325, 'MPa'}; % Environment pressure
end
parameters
    dynamic_compressibility = simscape.enum.onoff.on; % Fluid dynamic compressibility
end
parameters (ExternalAccess = none)
    p0 = {0.101325, 'MPa'}; % Initial liquid pressure
end
parameters
    T0 = {293.15,   'K'  }; % Initial liquid temperature
    x0_fluid = {0,'kg/m^3'}; % Initial species concentration
end

% Parameter groups
annotations
    UILayout = [
        UIGroup('physmod:simscape:library:tabs:Main', ...
            mech_orientation, rotation_spec, theta0, volume_displacement, dead_volume, ...
            area, environment_spec, environment_pressure)
        UIGroup('physmod:simscape:library:tabs:EffectsAndInitialConditions', ...
            dynamic_compressibility, p0, T0, x0_fluid)]
end

parameters (Access = private)
    min_volume = 1e-4 * dead_volume; % minimum physical volume
end

% Parameter checks and visibility
equations
    assert(volume_displacement > 0)
    assert(dead_volume > 0)
    assert(area > 0)
    assert(T0 >= A.T_min)
    assert(T0 <= A.T_max)
    assert(x0_fluid >= 0)
end

if rotation_spec == foundation.enum.RotationSpec.Calculate
    annotations
        theta0 : ExternalAccess = modify;
    end
    parameters (Access = private)
        theta0_priority = priority.high;
    end
    if mech_orientation == foundation.enum.MechOrientationRotational.Positive
        parameters (Access = private)
            mech_sign = 1;
        end
        equations
            assert(theta0 >= 0)
        end
    else % mech_orientation == foundation.enum.MechOrientationRotational.Negative
        parameters (Access = private)
            mech_sign = -1;
        end
        equations
            assert(theta0 <= 0)
        end
    end
else % rotation_spec == foundation.enum.RotationSpec.InputSignal
    annotations
        q_in : ExternalAccess = modify;
        Icon = 'rotational_mechanical_converter_input.svg';
    end
    parameters (Access = private)
        theta0_priority = priority.none;
    end
    if mech_orientation == foundation.enum.MechOrientationRotational.Positive
        parameters (Access = private)
            mech_sign = 1;
        end
    else % mech_orientation == foundation.enum.MechOrientationRotational.Negative
        parameters (Access = private)
            mech_sign = -1;
        end
    end
end

if environment_spec == foundation.enum.pressure_spec.atmospheric
    parameters (Access = private)
        p_environment = A.p_atm;
    end
else % environment_spec == foundation.enum.pressure_spec.specified
    annotations
        environment_pressure : ExternalAccess = modify;
    end
    parameters (Access = private)
        p_environment = environment_pressure;
    end
    equations
        assert(environment_pressure >= 0)
    end
end

if dynamic_compressibility == simscape.enum.onoff.on
    annotations
        p0 : ExternalAccess = modify;
    end
    parameters (Access = private)
        p_priority = priority.high;
    end
    equations
        assert(p0 >= A.p_min)
        assert(p0 <= A.p_max)
    end
else % dynamic_compressibility == simscape.enum.onoff.off
    parameters (Access = private)
        p_priority = priority.none;
    end
end

variables (Access = protected)
    mdot_A = {0, 'kg/s'}; % Mass flow rate into port A
    Phi_A  = {0, 'kW'  }; % Energy flow rate into port A
    mdot_A_x = {0, 'kg/s'}; % Species mass flow rate into port A
    Q_H    = {0, 'kW'  }; % Heat flow rate into port H

    p_I = {value = p0, priority = p_priority   }; % Pressure of liquid volume
    T_I = {value = T0, priority = priority.high}; % Temperature of liquid volume
    x_I = {value = x0_fluid, priority = priority.high}; % Species concentration

    interface_torque   = {0, 'N*m'}; % Liquid-exerted torque on the interface
    interface_rotation = {value = theta0, priority = theta0_priority}; % Interface rotation
end

branches
    mdot_A           : A.mdot -> *;
    Phi_A            : A.Phi  -> *;
    mdot_A_x         : A.mdot_x -> *;
    Q_H              : H.Q    -> *;
    interface_torque : R.t -> C.t;
end

% Determine rotation of port R relative to port C
if rotation_spec == foundation.enum.RotationSpec.Calculate
    equations
        der(interface_rotation) == interface_angular_velocity;
    end
else % rotation_spec == foundation.enum.RotationSpec.InputSignal
    equations
        interface_rotation == q_in;
    end
end

intermediates (Access = private, ExternalAccess = none)
    % Liquid properties table lookup
    cp_I = tablelookup(A.T_TLU, A.p_TLU, A.cp_TLU, T_I, p_I, interpolation = linear, extrapolation = linear);

    % Change in liquid volume
    der_volume = volume_displacement * interface_angular_velocity * mech_sign;
end

% For logging
intermediates (Access = private)
    rho_I = tablelookup(A.T_TLU, A.p_TLU, A.rho_TLU, T_I, p_I, interpolation = linear, extrapolation = linear); % Density of liquid volume
    u_I   = tablelookup(A.T_TLU, A.p_TLU, A.u_TLU,   T_I, p_I, interpolation = linear, extrapolation = linear); % Specific internal energy of liquid volume
    h_I   = u_I + p_I/rho_I; % Specific enthalpy of liquid volume

    interface_angular_velocity = R.w - C.w; % Interface angular velocity
    volume = dead_volume + volume_displacement * interface_rotation * mech_sign; % Liquid volume
end

annotations
    rho_I                      : LoggingUnit = 'kg/m^3';
    [u_I, h_I]                 : LoggingUnit = 'kJ/kg';
    volume                     : LoggingUnit = 'm^3';
    interface_angular_velocity : LoggingUnit = 'rad/s';
end

if dynamic_compressibility == simscape.enum.onoff.off

    equations
        % Mass balance
        rho_I * der_volume == mdot_A;

        % Energy conservation
        der(T_I) * cp_I * rho_I * volume + rho_I * h_I * der_volume == Phi_A + Q_H;
    end

else % dynamic_compressibility == simscape.enum.onoff.on

    intermediates (Access = private, ExternalAccess = none)
        % Liquid properties table lookup
        beta_I  = tablelookup(A.T_TLU, A.p_TLU, A.beta_TLU,  T_I, p_I, interpolation = linear, extrapolation = linear);
        alpha_I = tablelookup(A.T_TLU, A.p_TLU, A.alpha_TLU, T_I, p_I, interpolation = linear, extrapolation = linear);

        % Partial derivatives of internal energy of liquid volume
        % with respect to pressure and temperature at constasnt volume
        dUdp = (rho_I * h_I / beta_I - T_I * alpha_I) * volume;
        dUdT = (cp_I - h_I * alpha_I) * rho_I * volume;
    end

    equations
        % Mass conservation
        (der(p_I)/beta_I - der(T_I)*alpha_I) * rho_I * volume + rho_I * der_volume == mdot_A;

        % Energy conservation
        der(p_I)*dUdp + der(T_I)*dUdT + rho_I * h_I * der_volume == Phi_A + Q_H;
    end

end

equations
    % Assume no flow resistance
    A.p == p_I;

    % Assume no thermal resistance
    H.T == T_I;

    % Force balance on mechanical interface
    interface_torque / volume_displacement == (p_environment - p_I) * mech_sign;

    % Species conservation
    der(x_I) * volume + x_I * der_volume == mdot_A_x;

    % Run-time variable checks
    assert(volume > min_volume)
    let
        % Indicator variables for the valid region of the property tables
        indicator_pT_I = ...
            if A.pT_region_flag == foundation.enum.pT_region_TL.validity_matrix, ...
                tablelookup(A.T_TLU, A.p_TLU, A.pT_validity_TLU, T_I, p_I, interpolation = linear, extrapolation = linear) ...
            else ...
                1 ...
            end;
    in
        % Pressure and temperature must be within the valid region
        assert(indicator_pT_I > 0, message('physmod:simscape:library:thermal_liquid:PressureTemperatureVolumeValidRegion'), Action = A.properties_range_check)
        assert(p_I >= A.p_min, Action = A.properties_range_check)
        assert(p_I <= A.p_max, Action = A.properties_range_check)
        assert(T_I >= A.T_min, Action = A.properties_range_check)
        assert(T_I <= A.T_max, Action = A.properties_range_check)
    end
end

% Internal component that calculates energy convection at port A
components (ExternalAccess = none)
    convection_A = customization.thermal_liquid_custom.port_convection(flow_area = area, length_scale = sqrt(4*area/pi));
end
connections
    connect(A, convection_A.port)
end

% Equate variables for internal component that calculates energy convection at port A
equations
    convection_A.mdot == mdot_A;
    convection_A.Phi  == Phi_A;
    convection_A.mdot_x == mdot_A_x;
    convection_A.u_I  == u_I;
    convection_A.x_I  == x_I;
end

end