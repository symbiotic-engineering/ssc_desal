component pipe
% Pipe (SS) : 1.0
% This block models pipe flow dynamics in a thermal liquid network due to
% viscous friction losses and convective heat transfer between the liquid
% and the pipe wall. The effects of dynamic compressibility and fluid
% inertia can be optionally included.
%
% The pipe contains a constant volume of liquid. Temperature evolves based
% on the thermal capacity of this liquid volume. Setting Fluid dynamic
% compressibility to On also causes pressure to evolve based on the dynamic
% compressibility of the liquid volume. Setting Fluid inertia to On causes
% the liquid to resist acceleration.
%
% Ports A and B are the thermal liquid conserving ports associated with the
% pipe inlet and outlet. Port H is the thermal conserving port associated
% with the pipe wall.

% Copyright 2012-2022 The MathWorks, Inc.

nodes
    A = customization.solution.solution; % A
    H = foundation.thermal.thermal;               % H
    B = customization.solution.solution; % B
end

inputs
    dM_X = {0,"kg/s"};  % dM_X
    dM_W = {0,"kg/s"};  % dM_W
    Phi = {0, "W"};     % Phi
end

outputs (ExternalAccess = none)
    M = {0,"kg"}; % M
    P = {0.101325,"MPa"}; % P
    T = {293.15,"K"}; % T
    X = {0,"kg/m^3"}; % X
end

annotations
    [A,H] : Side = left;
    [Phi,B] : Side = right;
    [M,P,T,X,dM_X,dM_W] : Side = bottom;
end

parameters
    length       = {5,        'm'   }; % Pipe length
    area         = {0.01,     'm^2' }; % Cross-sectional area
    Dh           = {0.1128,   'm'   }; % Hydraulic diameter
    length_add   = {1,        'm'   }; % Aggregate equivalent length of local resistances
    roughness    = {15e-6,    'm'   }; % Internal surface absolute roughness
    Re_lam       = {2000,     '1'   }; % Laminar flow upper Reynolds number limit
    Re_tur       = {4000,     '1'   }; % Turbulent flow lower Reynolds number limit
    shape_factor = {64,       '1'   }; % Laminar friction constant for Darcy friction factor
    Nu_lam       = {3.66,     '1'   }; % Nusselt number for laminar flow heat transfer
    dynamic_compressibility = true;    % Fluid dynamic compressibility
end
parameters (ExternalAccess = none)
    inertia      = false;              % Fluid inertia
    p0           = {0.101325, 'MPa' }; % Initial liquid pressure
end
parameters
    T0           = {293.15,   'K'   }; % Initial liquid temperature
    x0           = {0,"kg/m^3"}; % Initial species concentration
end
parameters (ExternalAccess = none)
    mdot0        = {0,        'kg/s'}; % Initial mass flow rate from port A to port B
end



% Parameter groups
annotations
    UILayout = [
        UIGroup('physmod:simscape:library:tabs:Geometry', ...
            length, area, Dh)
        UIGroup('physmod:simscape:library:tabs:FrictionAndHeatTransfer', ...
            length_add, roughness, Re_lam, Re_tur, shape_factor, Nu_lam)
        UIGroup('physmod:simscape:library:tabs:EffectsAndInitialConditions', ...
            dynamic_compressibility, inertia, p0, T0, x0, mdot0)
        UIGroup('Measurements',m_measure,p_measure,t_measure,x_measure)
    ];
end

parameters
    m_measure = false; % Mass
    p_measure = false; % Pressure
    t_measure = false; % Temperature
    x_measure = false; % Species concentration
end

if m_measure
    annotations
        M : ExternalAccess = modify
    end
end
if p_measure
    annotations
        P : ExternalAccess = modify
    end
end
if t_measure
    annotations
        T : ExternalAccess = modify
    end
end
if x_measure
    annotations
        X : ExternalAccess = modify
    end
end

parameters (Access = private)
    surface_area = (4*area/Dh)*length; % Pipe surface area
    volume       = area * length;      % Pipe volume
end

% Parameter checks and visibility
equations
    assert(length > 0)
    assert(area > 0)
    assert(Dh > 0)
    assert(length_add >= 0)
    assert(roughness > 0)
    assert(Re_lam > 1)
    assert(Re_tur > Re_lam)
    assert(shape_factor > 0)
    assert(Nu_lam > 0)
    assert(T0 >= A.T_min)
    assert(T0 <= A.T_max)
end
if dynamic_compressibility
    annotations
        [inertia, p0] : ExternalAccess = modify;
    end
    equations
        assert(p0 >= A.p_min)
        assert(p0 <= A.p_max)
    end
    if inertia
        annotations
            mdot0 : ExternalAccess = modify;
        end
    end
end

variables (Access = protected)
    Phi_A = {0, 'kW'}; % Energy flow rate into port A
    Phi_B = {0, 'kW'}; % Energy flow rate into port B
    Q_H   = {0, 'kW'}; % Heat flow rate into port H
    mdot_A_x = {0, 'kg/s'}; % Species flow rate into port A
    mdot_B_x = {0, 'kg/s'}; % Species flow rate into port B

    T_I = {value = T0, priority = priority.high}; % Temperature of liquid volume
    x_I   = {value = x0, priority = priority.high}; % Species concentration of liquid volume
end

branches
    mdot_A : A.mdot -> *;
    mdot_B : B.mdot -> *;
    Phi_A  : A.Phi  -> *;
    Phi_B  : B.Phi  -> *;
    mdot_A_x : A.mdot_x -> *;
    mdot_B_x : B.mdot_x -> *;
    Q_H    : H.Q    -> *;
end

intermediates (Access = private, ExternalAccess = observe)
    % Liquid properties table lookup
    cp_I = tablelookup(A.T_TLU, A.p_TLU, A.cp_TLU, T_I, p_I, interpolation = linear, extrapolation = linear);
    mu_I = tablelookup(A.T_TLU, A.p_TLU, A.mu_TLU, T_I, p_I, interpolation = linear, extrapolation = nearest);
    k_I  = tablelookup(A.T_TLU, A.p_TLU, A.k_TLU,  T_I, p_I, interpolation = linear, extrapolation = nearest);
    Pr_I = tablelookup(A.T_TLU, A.p_TLU, A.Pr_TLU, T_I, p_I, interpolation = linear, extrapolation = nearest);

    % Liquid properties for inflow
    mu_A_in = tablelookup(A.T_TLU, A.p_TLU, A.mu_TLU, A.T, p_I, interpolation = linear, extrapolation = nearest);
    mu_B_in = tablelookup(A.T_TLU, A.p_TLU, A.mu_TLU, B.T, p_I, interpolation = linear, extrapolation = nearest);
    k_A_in  = tablelookup(A.T_TLU, A.p_TLU, A.k_TLU,  A.T, p_I, interpolation = linear, extrapolation = nearest);
    k_B_in  = tablelookup(A.T_TLU, A.p_TLU, A.k_TLU,  B.T, p_I, interpolation = linear, extrapolation = nearest);
    Pr_A_in = tablelookup(A.T_TLU, A.p_TLU, A.Pr_TLU, A.T, p_I, interpolation = linear, extrapolation = nearest);
    Pr_B_in = tablelookup(A.T_TLU, A.p_TLU, A.Pr_TLU, B.T, p_I, interpolation = linear, extrapolation = nearest);

    % Average mass flow rate from port A to port B
    mdot_avg = (mdot_A - mdot_B)/2;
    Re_avg = (mdot_avg * Dh) / (area * mu_I);

    % Convective heat transfer between pipe wall and liquid
    Q_AB = foundation.thermal_liquid.elements.pipe_convection(mdot_avg, A.T, H.T, ...
        (mu_A_in + mu_I)/2, (k_A_in + k_I)/2, (Pr_A_in + Pr_I)/2, ...
        area, Dh, surface_area, roughness/Dh, Re_lam, Re_tur, Nu_lam);

    Q_BA = foundation.thermal_liquid.elements.pipe_convection(-mdot_avg, B.T, H.T, ...
        (mu_B_in + mu_I)/2, (k_B_in + k_I)/2, (Pr_B_in + Pr_I)/2, ...
        area, Dh, surface_area, roughness/Dh, Re_lam, Re_tur, Nu_lam);

    Q_conv = simscape.function.blend(Q_BA, Q_AB, -Re_lam/100, Re_lam/100, Re_avg);

    % Conductive heat transfer between pipe wall and liquid
    Q_cond = k_I * surface_area / Dh * (H.T - T_I);
end

% For logging
intermediates (Access = private)
    rho_I = tablelookup(A.T_TLU, A.p_TLU, A.rho_TLU, T_I, p_I, interpolation = linear, extrapolation = linear); % Density of liquid volume
    u_I   = tablelookup(A.T_TLU, A.p_TLU, A.u_TLU,   T_I, p_I, interpolation = linear, extrapolation = linear); % Specific internal energy of liquid volume
    h_I   = u_I + p_I/rho_I; % Specific enthalpy of liquid volume

    rho_A = convection_A.rho; % Density at port A
    rho_B = convection_B.rho; % Density at port B
    q_A   = mdot_A/rho_A;     % Volumetric flow rate into port A
    q_B   = mdot_B/rho_B;     % Volumetric flow rate into port B
end

annotations
    [u_I, h_I]            : LoggingUnit = 'kJ/kg';
    [rho_A, rho_B, rho_I] : LoggingUnit = 'kg/m^3';
    [q_A, q_B]            : LoggingUnit = 'm^3/s';
end

if ~dynamic_compressibility

    variables (Access = private)
        mdot_A = {0, 'kg/s'}; % Mass flow rate into port A
        mdot_B = {0, 'kg/s'}; % Mass flow rate into port B
    end

    % For logging
    intermediates (Access = private)
        p_I = (A.p + B.p)/2; % Pressure of liquid volume

        pressure_loss = foundation.thermal_liquid.elements.pipe_friction( ...
            mdot_A, ...
            rho_I, ...
            mu_I, ...
            area, ...
            Dh, ...
            length+length_add, ...
            roughness/Dh, ...
            Re_lam, Re_tur, shape_factor); % Viscous friction pressure loss
    end

    annotations
        [p_I, pressure_loss] : LoggingUnit = 'MPa';
    end

    equations
        % Solvent balance
        mdot_A + mdot_B + dM_W == 0;

        % Energy conservation
        der(T_I) * cp_I * rho_I * volume == Phi_A + Phi_B + Q_H + Phi;

        % Momentum balance
        A.p - B.p == pressure_loss;

        % Species balance
        mdot_A_x + mdot_B_x + dM_X == 0;
    end

else % dynamic_compressibility

    variables (Access = private)
        p_I = {value = p0, priority = priority.high}; % Pressure of liquid volume
    end

    intermediates (Access = private, ExternalAccess = none)
        % Liquid properties table lookup
        beta_I  = tablelookup(A.T_TLU, A.p_TLU, A.beta_TLU,  T_I, p_I, interpolation = linear, extrapolation = linear);
        alpha_I = tablelookup(A.T_TLU, A.p_TLU, A.alpha_TLU, T_I, p_I, interpolation = linear, extrapolation = linear);

        % Partial derivatives of internal energy of liquid volume
        % with respect to pressure and temperature
        dUdp = (rho_I * h_I / beta_I - T_I * alpha_I) * volume;
        dUdT = (cp_I - h_I * alpha_I) * rho_I * volume;
    end

    % For logging
    intermediates (Access = private)
        pressure_loss_A = foundation.thermal_liquid.elements.pipe_friction( ...
            mdot_A, ...
            rho_I, ...
            mu_I, ...
            area, ...
            Dh, ...
            (length + length_add)/2, ...
            roughness/Dh, ...
            Re_lam, Re_tur, shape_factor); % Viscous friction pressure loss at port A

        pressure_loss_B = foundation.thermal_liquid.elements.pipe_friction( ...
            mdot_B, ...
            rho_I, ...
            mu_I, ...
            area, ...
            Dh, ...
            (length + length_add)/2, ...
            roughness/Dh, ...
            Re_lam, Re_tur, shape_factor); % Viscous frictional pressure loss at port B
    end

    annotations
        [pressure_loss_A, pressure_loss_B] : LoggingUnit = 'MPa';
    end

    equations
        % Mass conservation
        (der(p_I)/beta_I - der(T_I)*alpha_I) * rho_I * volume == mdot_A + mdot_B + dM_W;

        % Energy conservation
        der(p_I)*dUdp + der(T_I)*dUdT == Phi_A + Phi_B + Q_H + Phi;

        % Species conservation
        der(x_I) * volume == mdot_A_x + mdot_B_x + dM_X;
    end

    if ~inertia

        variables (Access = private)
            mdot_A = {0, 'kg/s'}; % Mass flow rate into port A
            mdot_B = {0, 'kg/s'}; % Mass flow rate into port B
        end

        equations
            % Momentum balance
            A.p - p_I == pressure_loss_A;
            B.p - p_I == pressure_loss_B;
        end

    else % inertia

        variables (Access = private)
            mdot_A = {value =  mdot0, priority = priority.high}; % Mass flow rate into port A
            mdot_B = {value = -mdot0, priority = priority.high}; % Mass flow rate into port B
        end

        % For logging
        intermediates (Access = private)
            inertia_A = A.p - p_I - pressure_loss_A; % Fluid inertia at port A
            inertia_B = B.p - p_I - pressure_loss_B; % Fluid inertia at port B
        end

        annotations
            [inertia_A, inertia_B] : LoggingUnit = 'MPa';
        end

        equations
            % Momentum balance
            A.p - p_I == der(mdot_A)*length/2/area + pressure_loss_A;
            B.p - p_I == der(mdot_B)*length/2/area + pressure_loss_B;
        end
    end
end

equations
    % Heat transfer
    Q_H == Q_conv + Q_cond;

    % Signal outputs
    M == volume * rho_I;
    P == p_I;
    T == T_I;
    X == x_I;

    % Run-time variable checks
    let
        % Indicator variables for the valid region of the property tables
        [indicator_pT_A, indicator_pT_B, indicator_pT_I] = ...
            if A.pT_region_flag == foundation.enum.pT_region_TL.validity_matrix, ...
                tablelookup(A.T_TLU, A.p_TLU, A.pT_validity_TLU, A.T, A.p, interpolation = linear, extrapolation = linear); ...
                tablelookup(A.T_TLU, A.p_TLU, A.pT_validity_TLU, B.T, B.p, interpolation = linear, extrapolation = linear); ...
                tablelookup(A.T_TLU, A.p_TLU, A.pT_validity_TLU, T_I, p_I, interpolation = linear, extrapolation = linear) ...
            else ...
                1; ...
                1; ...
                1 ...
            end;
    in
        % Pressure and temperature must be within the valid region
        assert(indicator_pT_A > 0, message('physmod:simscape:library:thermal_liquid:PressureTemperaturePortValidRegion', 'A'), Action = A.properties_range_check)
        assert(A.p >= A.p_min, message('physmod:simscape:library:thermal_liquid:PressureMinValid', 'A'), Action = A.properties_range_check)
        assert(A.p <= A.p_max, message('physmod:simscape:library:thermal_liquid:PressureMaxValid', 'A'), Action = A.properties_range_check)
        assert(A.T >= A.T_min, message('physmod:simscape:library:thermal_liquid:TemperatureMinValid', 'A'), Action = A.properties_range_check)
        assert(A.T <= A.T_max, message('physmod:simscape:library:thermal_liquid:TemperatureMaxValid', 'A'), Action = A.properties_range_check)
        assert(indicator_pT_B > 0, message('physmod:simscape:library:thermal_liquid:PressureTemperaturePortValidRegion', 'B'), Action = A.properties_range_check)
        assert(B.p >= A.p_min, message('physmod:simscape:library:thermal_liquid:PressureMinValid', 'B'), Action = A.properties_range_check)
        assert(B.p <= A.p_max, message('physmod:simscape:library:thermal_liquid:PressureMaxValid', 'B'), Action = A.properties_range_check)
        assert(B.T >= A.T_min, message('physmod:simscape:library:thermal_liquid:TemperatureMinValid', 'B'), Action = A.properties_range_check)
        assert(B.T <= A.T_max, message('physmod:simscape:library:thermal_liquid:TemperatureMaxValid', 'B'), Action = A.properties_range_check)
        assert(indicator_pT_I > 0, message('physmod:simscape:library:thermal_liquid:PressureTemperatureVolumeValidRegion'), Action = A.properties_range_check)
        assert(p_I >= A.p_min, Action = A.properties_range_check)
        assert(p_I <= A.p_max, Action = A.properties_range_check)
        assert(T_I >= A.T_min, Action = A.properties_range_check)
        assert(T_I <= A.T_max, Action = A.properties_range_check)

        assert(x_I/A.rho_species < A.fm,'Species volume fraction exceeds maximum.');
        assert(A.x/A.rho_species < A.fm,'Species volume fraction exceeds maximum.');
        assert(B.x/A.rho_species < A.fm,'Species volume fraction exceeds maximum.');
    end
end

% Internal components that calculate energy convection at ports A and B
components (ExternalAccess = none)
    convection_A = customization.solution.port_convection(flow_area = area, length_scale = length/2);
    convection_B = customization.solution.port_convection(flow_area = area, length_scale = length/2);
end
connections
    connect(A, convection_A.port)
    connect(B, convection_B.port)
end

% Equate variables for internal components that calculate energy convection at ports A and B
equations
    convection_A.mdot == mdot_A;
    convection_A.Phi  == Phi_A;
    convection_A.mdot_x == mdot_A_x;
    convection_A.u_I  == u_I;
    convection_A.x_I  == x_I;
    convection_B.mdot == mdot_B;
    convection_B.Phi  == Phi_B;
    convection_B.mdot_x == mdot_B_x;
    convection_B.u_I  == u_I;
    convection_B.x_I  == x_I;
end

end