component reservoir
% Reservoir (SS)
% This block sets constant boundary conditions in a thermal liquid network.
% The volume of liquid inside the reservoir is assumed infinite. Therefore,
% the flow is assumed quasi-steady. Liquid leaves the reservoir at the
% reservoir pressure and temperature. Liquid enters the reservoir at the
% reservoir pressure, but its temperature is determined by the thermal
% liquid network upstream.
% The concentation behaves like the temperature, where fluid leaves the
% reservoir at the reservoir temperature, but fluid entering the reservoir
% is determind by the upstream netork.
%
% Copyright 2012-2025 The MathWorks, Inc.

nodes
    A = customization.solution.solution; % A:top
end

parameters
    pressure_spec = foundation.enum.pressure_spec.atmospheric; % Reservoir pressure specification
    %                                                            1 - atmospheric
    %                                                            2 - specified
end
parameters (ExternalAccess = none)
    reservoir_pressure    = {0.101325, 'MPa'}; % Reservoir pressure
end
parameters
    reservoir_temperature = {293.15,   'K'  }; % Reservoir temperature
    reservoir_concentration = {0, 'kg/m^3'}; % Reservoir concentration - new parameter
    area                  = {0.01,     'm^2'}; % Cross-sectional area at port A
end

% Parameter checks and visibility
parameters (Access = private)
    % Indicator variables for the valid region of the property tables
    indicator_pT_I = ...
        if A.pT_region_flag == foundation.enum.pT_region_TL.validity_matrix, ...
            tablelookup(A.T_TLU, A.p_TLU, A.pT_validity_TLU, reservoir_temperature, p_reservoir, interpolation = linear, extrapolation = linear) ...
        else ...
            1 ...
        end;
end
equations
    assert(indicator_pT_I > 0, message('physmod:simscape:library:thermal_liquid:PressureTemperatureVolumeValidRegion'))
    assert(reservoir_temperature >= A.T_min)
    assert(reservoir_temperature <= A.T_max)
    assert(area > 0)
end
if pressure_spec == foundation.enum.pressure_spec.atmospheric
    parameters (Access = private)
        p_reservoir = A.p_atm;
    end
else % pressure_spec == foundation.enum.pressure_spec.specified
    annotations
        reservoir_pressure : ExternalAccess = modify;
    end
    parameters (Access = private)
        p_reservoir = reservoir_pressure;
    end
    equations
        assert(reservoir_pressure >= A.p_min)
        assert(reservoir_pressure <= A.p_max)
    end
end

variables (Access = protected)
    mdot_A = {0, 'kg/s'}; % Mass flow rate into port A
    Phi_A  = {0, 'kW'  }; % Energy flow rate into port A
    mdot_A_x = {0, 'kg/s'}; % Species flow rate into port A - extra through variable

    p_I = {0.1, 'MPa'}; % Reservoir pressure
    T_I = {300, 'K'  }; % Reservoir temperature
    x_I = {0, 'kg/m^3'}; % Reservoir concentration - extra across variable 
end

branches
    mdot_A : A.mdot -> *;
    Phi_A  : A.Phi  -> *;
    mdot_A_x : A.mdot_x -> *; % Extra branch for through variable mapping
end

% For logging
intermediates (Access = private)
    rho_I = x_I + tablelookup(A.T_TLU, A.p_TLU, A.rho_TLU, T_I, p_I, interpolation = linear, extrapolation = linear); % Reservoir density, (NDG) now adds concentration
    u_I   = tablelookup(A.T_TLU, A.p_TLU, A.u_TLU,   T_I, p_I, interpolation = linear, extrapolation = linear); % Reservoir specific internal energy
    h_I   = u_I + p_I/rho_I; % Reservoir specific enthalpy
end

annotations
    rho_I      : LoggingUnit = 'kg/m^3';
    [u_I, h_I] : LoggingUnit = 'kJ/kg';
end

equations
    % Assume no flow resistance
    A.p == p_I;

    % Reservoir pressure, temperature and species concentration
    p_I == p_reservoir;
    T_I == reservoir_temperature;
    x_I ==  reservoir_concentration; % Extra equation for concentration
end

% Internal component that calculates energy convection at port A
components (ExternalAccess = none)
    convection_A = customization.solution.port_convection(flow_area = area, length_scale = sqrt(4*area/pi));
end
connections
    connect(A, convection_A.port)
end

% Equate variables for internal component that calculates energy convection at port A
equations
    convection_A.mdot == mdot_A;
    convection_A.Phi  == Phi_A;
    convection_A.mdot_x == mdot_A_x; % Extra convection equation for through variable
    convection_A.u_I  == u_I;
    convection_A.x_I  == x_I; % Extra convection equation for across variable
end

end